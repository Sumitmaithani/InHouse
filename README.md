# InHouse
website link : https://inhouse-thz1.onrender.com

"Collaborate and code in real-time with InHouse, the fast and focussed platform for peer-to-peer coding sessions."

<p>
<img src="https://user-images.githubusercontent.com/86047367/211190221-2ea5ad86-a7c2-4ed2-8007-5793815b1cd5.png" width=1000 />
<p>

## The problem InHouse solves
InHouse is a platform that aims to solve the problem of collaborating on code and code-pairing remotely. It offers a way for developers to work on code together in real-time, similar to using a tool like Visual Studio Code, but with a focus on being lightweight and easy to use. It also includes text messaging functionality, which can be helpful for communicating and coordinating during a code-pairing session. Some of the specific problems that InHouse aims to solve include:

1.Difficulties collaborating remotely: InHouse makes it easier for developers to collaborate on code and work on projects together, even when they are not in the same physical location. It's a great way to overcome the challenges of working remotely and stay connected with team members.

2.Poor connectivity issues: InHouse has low bandwidth requirements, which means it can be used even on connections with low speeds. This can be especially helpful for developers who don't have access to a high-speed internet connection or who experience connectivity issues.

3.Distractions and cluttered interfaces: InHouse has a more focused and streamlined interface compared to other code-pairing tools, which can help reduce distractions and make it easier to use. This can be particularly helpful when working on complex projects and trying to stay focused.

4.Limited collaboration options: InHouse allows developers to create both public and private rooms, which gives them the flexibility to choose who they want to collaborate with. It also supports multiple users, which makes it easier for teams to work together and share ideas.

## Challenges I ran into
Here are the five challenges we faced while building the InHouse project, along with potential solutions:

1.Deciding on the technologies to use: We faced the challenge of deciding on the technologies to use for the InHouse project. To address this challenge, we held a brainstorming session with our team or stakeholders to discuss the various options and consider their pros and cons. We also did research on the available technologies and their suitability for the project.

2.Implementing secure authentication and authorization: We faced the challenge of implementing secure authentication and authorization for InHouse. To address this challenge, we decided to use cookies to store access and refresh tokens. We also implemented axios middleware interceptors to handle the cookies and ensure that they were used appropriately.

3.Enabling real-time peer-to-peer connections for multiple users: We faced the challenge of enabling real-time peer-to-peer connections for multiple users in InHouse. To address this challenge, we decided to use socket.io and CodeMirror. Socket.io is a library that enables real-time communication between clients and servers, while CodeMirror is a code editor that can be used to build interactive and collaborative code editors. By using these technologies, we were able to provide a seamless and efficient experience for users of InHouse.

4.Managing complexity: As a full-stack real-time code collaboration tool, InHouse required a significant amount of complex functionality to be implemented. We faced the challenge of managing this complexity. To address this challenge, we broke the project down into smaller pieces and focused on one piece at a time. We also used good coding practices and techniques, such as modular design and testing, to ensure that the code was maintainable and easy to work with.

5.Ensuring a smooth user experience: In a real-time code collaboration tool like InHouse, it is important to ensure that the user experience is smooth and seamless. We faced the challenge of ensuring a smooth user experience. To address this challenge, we focused on optimizing performance and reducing latency. We also tested the tool thoroughly and addressed any issues or bugs that were discovered. By paying close attention to the user experience, we were able to deliver a high-quality product that meets the needs of our users.

## Technologies I used

• React

• Redux

• codemirror

• Node.js

• Express.js

• MongoDB

• Socket.IO

• JWT

• CI/CD

• Twilio

## Screnshots

<p>
<img src="https://user-images.githubusercontent.com/86047367/211190376-0eff44f1-18af-4ddd-918a-746ff488c45c.png" width=500 />
<img src="https://user-images.githubusercontent.com/86047367/211190380-00e101bf-7b50-4092-8eed-0f24f0e0f214.png" width=500 />
<p>
<p>
<img src="https://user-images.githubusercontent.com/86047367/211190390-1d533087-2f29-4e62-b06a-5fff46216c06.png" width=500 />
<img src="https://user-images.githubusercontent.com/86047367/211190392-4a5d4bd6-c296-4789-a6c9-af922d249540.png" width=500 />
<p>
<p>
<img src="https://user-images.githubusercontent.com/86047367/211190526-91715dcb-c0ef-4f85-98b9-c7e02c9c8e42.png" width=500 />
<img src="https://user-images.githubusercontent.com/86047367/211190396-d2e1a5e2-e0cc-4786-b419-164c4bac16a9.png" width=500 />
<p>
